//  matrix.icc
//  Created by Daniel Palken in 2014 for G4CMP
//  20160507  M. Kelsey -- Split from matrix.h 

#ifndef _matrix_icc
#define _matrix_icc

// @@@@@@@@@@@@@@@@@@@@@@@@@@@  Matrix Class @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

template <class T>
matrix<T>::matrix(size_t n, size_t m) : nn(n), mm(m), v(NULL) { fill(); }

template <class T>
matrix<T>::matrix(size_t n, size_t m, const T &a) : nn(n), mm(m), v(NULL) { fill(a); }

template <class T>
matrix<T>::matrix(size_t n, size_t m, const T *a) : nn(n), mm(m), v(NULL) { *this=a; }

template <class T>
matrix<T>::matrix(const matrix &rhs) : nn(0), mm(0), v(NULL) { *this = rhs; }

template <class T>
matrix<T>& matrix<T>::operator=(const matrix<T> &rhs)
// postcondition: normal assignment via copying has been performed;
//		if matrix and rhs were different sizes, matrix
//		has been resized to match the size of rhs
{
  if (this != &rhs) {
    resize(rhs.nn, rhs.mm);		// No effect if equal dimensions
    for (size_t i=0; i<nn; i++) for (size_t j=0; j<mm; j++) v[i][j] = rhs[i][j];
  }
  return *this;
}

template <class T>
matrix<T>& matrix<T>::operator=(const T *a) {		// Copy array entries
  if (!v || !v[0]) resize(nn,mm);
  for (size_t i=0; i<nn; i++) for (size_t j=0; j<mm; j++) v[i][j] = *a++;
}
 

template <class T>
inline void matrix<T>::resize(size_t n, size_t m) {
  if (n == nn && m == mm && v && v[0]) return;		// Already correct size
  clear();

  v = new T*[n];
  v[0] = new T[n*m];
  if (v && v[0]) for (size_t i=1; i<n; i++) v[i] = v[i-1] + m;

  nn=n; mm=m;
}

template <class T>
inline void matrix<T>::resize(size_t n, size_t m, const T& a) {
  resize(n,m);
  fill(a);
}

template <class T>
inline void matrix<T>::fill(const T &a) {		// Initialize elements
  if (!v || !v[0]) resize(nn,mm);
  for (size_t i=0; i<nn; i++) for (size_t j=0; j<mm; j++) v[i][j] = a;
}

template <class T>
inline T& matrix<T>::at(size_t i, size_t j) {			// double subscripting
#ifdef _CHECKBOUNDS_
    if (i>=nn || j>=mm) throw("matrix subscript out of bounds");
#endif
    return v[i][j];
}

template <class T>
inline const T& matrix<T>::at(size_t i, size_t j) const {
#ifdef _CHECKBOUNDS_
  if (i>=nn || j>=mm) throw("matrix subscript out of bounds");
#endif
  return v[i][j];
}


template <class T>
inline T* matrix<T>::operator[](size_t i) {	//subscripting: pointer to row i
#ifdef _CHECKBOUNDS_
  if (i>=nn) throw("matrix subscript out of bounds");
#endif
  return v[i];
}

template <class T>
inline const T* matrix<T>::operator[](size_t i) const
{
#ifdef _CHECKBOUNDS_
  if (i>=nn) throw("matrix subscript out of bounds");
#endif
  return v[i];
}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#endif	/* matrix_icc */
