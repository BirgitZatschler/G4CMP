#include "ElectronLukeScatteringProcess.hh"
#include "DriftingElectron.hh"
#include "DriftingHole.hh"

#include "LPhonon.hh"
#include "PhononTrackInformation.hh"
#include "LatticeManager2.hh"
#include "PhysicalLattice.hh"

#include "G4Step.hh"
#include "G4VParticleChange.hh"
#include "Randomize.hh"
#include "G4RandomDirection.hh"
#include <fstream>
#include <iostream>
#include "DriftingElectronTrackInformation.hh"


#include "G4Geantino.hh"


/*ElectronLukeScatteringProcess::ElectronLukeScatteringProcess(const G4String& aName)
  : G4VDiscreteProcess(aName)
{

  G4cout<<"\nWARNING:\n\tElectronLukeScatteringProcess::Constructor: Called constructor with pointer to step limitier! Process will not be properly initialised!!!"<<endl;
  if(verboseLevel>1){
    G4cout<<GetProcessName()<<" is created "<<G4endl;
  }
}
*/

ElectronLukeScatteringProcess::ElectronLukeScatteringProcess(G4VProcess* sLim)
 :G4VDiscreteProcess("ElectronLukeScattering")
{
  velLong=5324.2077*m/s;
  l0Hole = 257e-6*m;
  massFreeElectron=9.1e-31*kg;
  massHole=.12*massFreeElectron;
  hbar= 6.5821e-16*eV*s;
  //ksound_Hole=5512124.0235/m; //velLong*massHole / hbar;//1.6306e7/m;
  ksound_Hole = velLong*massHole/hbar_Planck;
  G4cout<<"\nElectronLukeScatteringProcess::Constructor:ksound_Hole = "
	<<ksound_Hole*m<<" /m"<<G4endl;

	stepLimiter = sLim;
  /*
    normalToValley= G4AffineTransform
    (G4RotationMatrix(G4ThreeVector(1.0,0,0), 0.95532));
  valleyToNormal= G4AffineTransform
    (G4RotationMatrix(G4ThreeVector(1.0,0,0), 0.95532)).Inverse();
  */

  /*
  HVMatrix = G4RotationMatrix(G4ThreeVector(1.2172, 0     ,     0),
				      G4ThreeVector(0     , 1.2172,     0),
				      G4ThreeVector(0     , 0     ,0.2756)
				      );
  HVTransform = G4AffineTransform(HVMatrix);
  */

  if(verboseLevel>1){
    G4cout<<GetProcessName()<<" is created "<<G4endl;
  }
}

ElectronLukeScatteringProcess::~ElectronLukeScatteringProcess()
{ ; }

ElectronLukeScatteringProcess::ElectronLukeScatteringProcess(ElectronLukeScatteringProcess& right)
  : G4VDiscreteProcess(right)
{ ; }

G4double ElectronLukeScatteringProcess::GetMeanFreePath(const G4Track& aTrack, G4double, G4ForceCondition* condition)
{
  G4double me=electron_mass_c2/c_squared;
  G4double mc = .118*me;

  G4RotationMatrix trix;
  int valley = ((DriftingElectronTrackInformation*) aTrack.GetUserInformation())->getValley();
  switch(valley){
      case 1:
          trix = G4RotationMatrix(-PI/4, -PI/4, PI/4);
          break;
      case 2:
          trix = G4RotationMatrix(PI/4, -PI/4, -PI/4);
          break;
      case 3:
          trix = G4RotationMatrix(-PI/4, PI/4, PI/4);
          break;
      case 4:
          trix = G4RotationMatrix(PI/4, PI/4, -PI/4);
          break;
  }
  
  normalToValley= G4AffineTransform(trix);
  valleyToNormal= G4AffineTransform(trix).Inverse();

  G4ThreeVector T = G4ThreeVector(sqrt(.12/.081), sqrt(.12/.081), sqrt(.12/1.58));
  G4ThreeVector k = aTrack.GetMomentum()/hbarc;
  G4ThreeVector k_valley = normalToValley.TransformPoint(k);
  G4ThreeVector k_HV =  G4ThreeVector(k_valley[0]*T[0], 
					k_valley[1]*T[1], 
					k_valley[2]*T[2]);
					
  *condition = Forced;

  G4double kmag = k_HV.mag();
  G4ThreeVector v_HV = hbar_Planck*k_HV/mc;
  G4ThreeVector v_valley =  G4ThreeVector(v_HV[0]*T[0], 
					v_HV[1]*T[1], 
					v_HV[2]*T[2]);
   G4ThreeVector v = valleyToNormal.TransformAxis(v_valley);
  //G4cout << "kmag = " << kmag*m << G4endl;
  G4double tau;
  if (kmag<=ksound_Hole) return DBL_MAX;

  tau =  1.0 / (
		       10.0*velLong / (3*l0Hole)
		       * (kmag / ksound_Hole)
		       * ((1- ksound_Hole /kmag))
		       * ((1- ksound_Hole /kmag))
		       * ((1- ksound_Hole /kmag))
		       );
  //G4double mfp = tau*v_HV.mag();
  G4double mfp = tau*v.mag();
  //G4cout << v.mag() << G4endl;
  //G4cout << aTrack.GetVelocity() << G4endl;
  //G4cout << aTrack.GetMomentum().mag()/mc/c_light << G4endl;
  //G4double mfp = tau*aTrack.GetVelocity();
  G4cout << mfp/m << G4endl;
    return mfp;
}

G4VParticleChange* ElectronLukeScatteringProcess::PostStepDoIt(const G4Track& aTrack, const G4Step& aStep)
{
  G4cout << "Luke Emission" << G4endl;
  G4double me=electron_mass_c2/c_squared;
  G4double mx=0.081*me;
  G4double my=0.081*me;
  G4double mz=1.58*me;
  G4double mc = .12*me;
  aParticleChange.Initialize(aTrack); 
  G4RotationMatrix trix;
  int valley = ((DriftingElectronTrackInformation*) 
aTrack.GetUserInformation())->getValley();
//if (valley != 2 && valley != 3)
//G4cout << "valley = " << valley << G4endl;
  switch(valley){
      case 1:
          trix = G4RotationMatrix(-PI/4, -PI/4, PI/4);
          break;
      case 2:
          trix = G4RotationMatrix(PI/4, -PI/4, -PI/4);
          break;
      case 3:
          trix = G4RotationMatrix(-PI/4, PI/4, PI/4);
          break;
      case 4:
          trix = G4RotationMatrix(PI/4, PI/4, -PI/4);
          break;
  }
  
  G4StepPoint* postStepPoint = aTrack.GetStep()->GetPostStepPoint();
  normalToValley= G4AffineTransform(trix);
  valleyToNormal= G4AffineTransform(trix).Inverse();
  
  G4ThreeVector T = G4ThreeVector(sqrt(.12/.081), sqrt(.12/.081), sqrt(.12/1.58));
  G4ThreeVector k = postStepPoint->GetMomentum()/hbarc;
  G4ThreeVector k_valley = normalToValley.TransformPoint(k);
  G4ThreeVector k_HV =  G4ThreeVector(k_valley[0]*T[0], 
					k_valley[1]*T[1], 
					k_valley[2]*T[2]);
					
  G4double kmag = k_HV.mag(); 
  
  //Do nothing other than re-calculate mfp when step limit reached or leaving 
  //volume
  if((postStepPoint->GetProcessDefinedStep()==stepLimiter)
||(postStepPoint->GetStepStatus()==fGeomBoundary)
       || (kmag <= ksound_Hole)
     )
    {     
	return &aParticleChange;
    }  

  G4cout << "Luke Emission1" << G4endl;
  G4double theta_phonon= MakeTheta(kmag, ksound_Hole);
  //G4cout << theta_phonon << G4endl;

  G4double theta_charge=acos( 
			     (kmag*kmag - 2*ksound_Hole
			      *(kmag*cos(theta_phonon) - ksound_Hole) 
			      - 2 * (kmag*cos(theta_phonon) - ksound_Hole)
			      * (kmag*cos(theta_phonon) - ksound_Hole)
			      ) 
			     / kmag
			     / (sqrt(
				     kmag*kmag - 4*ksound_Hole
				     *(kmag*cos(theta_phonon) - ksound_Hole)
				     )) 
			     );

    //G4double T = kmag*kmag*hbar_Planck*hbar_Planck/2/mc;
  G4double q = 2*(kmag*cos(theta_phonon)-ksound_Hole);
  //G4cout <<  k_HV.mag()*m << G4endl;
  //G4cout <<  q << G4endl;
  //G4cout << k_HV.mag2()*hbar_Planck*hbar_Planck/2/mc <<  G4endl;
  //G4double Energy = k_HV.mag2()*hbar_Planck*hbar_Planck/2/mc;
  G4double kold = k_HV.mag();
  k_HV.setMag(sqrt(k_HV.mag2() + q*q - 2*kmag*q*cos(theta_phonon)));
  //k_HV.setMag(sqrt(2*mc*newE/hbar_Planck/hbar_Planck));

  G4ThreeVector kdir = k_HV.unit();
  k_HV.rotate(theta_charge, kdir.orthogonal());

  G4double phi_charge =  G4UniformRand()*2*pi;
  k_HV.rotate(phi_charge, kdir);
  
  G4double Energy = k_HV.mag2()*hbar_Planck*hbar_Planck/2/mc;
  G4double oldE = kold*kold*hbar_Planck*hbar_Planck/2/mc;
  //G4cout << postStepPoint->GetKineticEnergy() << G4endl;
  //G4cout << qEnergy << G4endl;
  //G4cout << q*q*hbar_Planck*hbar_Planck/2/mc << G4endl;
  //G4cout << oldE << G4endl;
  //G4cout << Energy << G4endl;
G4ThreeVector v_new = hbar_Planck/mc*k_HV;
v_new = G4ThreeVector(v_new[0]*T[0], v_new[1]*T[1], v_new[2]*T[2]);
//Energy = .5 * (v_new[0]*v_new[0]*mx, v_new[1]*v_new[1]*my, 
//v_new[2]*v_new[2]*mz);
valleyToNormal.ApplyPointTransform(v_new);

G4ThreeVector p_new = hbar_Planck*k_HV;
p_new[0] /= T[0];
p_new[1] /= T[1];
p_new[2] /= T[2];
valleyToNormal.ApplyPointTransform(p_new);

/*
  std::ofstream epositions;
  epositions.open("qenergies.txt", std::ofstream::app);
files
  epositions << aTrack.GetKineticEnergy()/eV - Energy << "\n";
  epositions.close();
  */


//    std::ofstream energy;
//    energy.open("energy", std::ofstream::app);
//  
//    energy<< aTrack.GetKineticEnergy()/eV << "\n";
//    energy.close();
   
    std::ofstream qwave;
    qwave.open("q", std::ofstream::app);
    qwave << hbar_Planck*velLong*q/eV << "\n";
    qwave.close();
//   
//   std::ofstream kwave;
//   kwave.open("k", std::ofstream::app);
// 
//   kwave << oldE/eV - Energy/eV << "\n";
//   kwave.close();
  
  
  //G4cout << postStepPoint->GetVelocity()*s/m << G4endl;
  //G4cout << v_new.mag()*s/m << G4endl;
  aParticleChange.ProposeMomentumDirection(p_new.unit());
  //aParticleChange.ProposeVelocity(v_new.mag()); 
  //aParticleChange.ProposeEnergy(Energy);
  aParticleChange.ProposeEnergy(p_new.mag2()/2/aTrack.GetDefinition()->GetPDGMass()*c_squared);
  //aParticleChange.ProposeEnergy(aTrack.GetKineticEnergy()-velLong*hbar_Planck*q);
  //aParticleChange.ProposeEnergy(T -velLong*hbar_Planck*q);
  ResetNumberOfInteractionLengthLeft();
  return &aParticleChange;
}

G4double ElectronLukeScatteringProcess::MakeTheta(G4double& k, G4double& ks){
     G4double u = G4UniformRand();
 
  //Analytical method to compute theta
  

  double base = -(u-1)+3*(u-1)*(ks/k)-3*(u-1)*(ks/k)*(ks/k)+(u-1)*(ks/k)*(ks/k)*(ks/k);
  double exponent =1.0/3.0;
  G4double operand = ks/k+pow(base, exponent);   

  if(operand>1.0) {
    // G4cout<<"\nTruncating operand from"<<operand<<" to 1.0";
    operand=1.0;
  }
  if(operand<0.0) G4cout<<"\noperand out of range: operand = "<<operand;
  G4double theta=acos(operand);
  //  G4cout<<"\n"<<theta;

  if(acos(ks/k)<theta) G4cout<<"\n  THETA OUT OF BOUNDS!!! (theta>acos(ks/k)) theta:"<<theta<<" acos(ks/k):"<<acos(ks/k);
  if(PI/2<=theta) G4cout<<"\n THETA OUT OF BOUNDS!!! (pi/2 < theta)";
      
      /*
  //Rejection method for determining theta
  G4double theta;
  G4double pValue=2;
  G4double pDensity = 1;

  G4double thetaMax;
  G4double pValMax;
  thetaMax=acos(ks/k);
  pValMax=(1-(ks/k))*(1-(ks/k));
  bool first = true;

  while(pValue>pDensity){
    pValue=G4UniformRand();//*pValMax;//  *(1+2*ks/k+(ks/k)*(ks/k));   
    theta=G4UniformRand()*thetaMax;
    pDensity = (cos(theta)-(ks/k))*(cos(theta)-(ks/k))*sin(theta);//need to multiply by unit 's' to make it dimensionless
    if(pDensity>pValMax) G4cout<<"\nLukeScattering::PostStepDoIt: Error: pDensity should never exceed pValMax "<<pValMax;
    
    
    //    if(!first){
    //G4cout<<"\nLukeScatteringProcess::MakeTheta: pDensity calculated as: 
//"<<pDensity;
  //   G4cout<<"\n\tpValue: "<<pValue;
    // G4cout<<"\n\ttheta: "<<theta/rad;
    // G4cout<<"\n\tk: "<<k*m;
   //  G4cout<<"\n\tks: "<<ks*m;
   //  G4cout<<endl;
    //}
    first=false;
    
  }
  */
  return theta;
}

G4double ElectronLukeScatteringProcess::MakePhi(G4double& k,G4double& ks, G4double& theta){


  G4double phi=acos((k*k - 2*ks*(k*cos(theta)-ks)-2*(k*cos(theta)-ks)*(k*cos(theta)-ks))/(k*sqrt(k*k-4*ks*(k*cos(theta)-ks))));

  return phi;
}

G4bool ElectronLukeScatteringProcess::IsApplicable(const G4ParticleDefinition& aPD)
{
  
return((&aPD==DriftingElectron::Definition()));
}