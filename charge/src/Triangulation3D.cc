#include "Triangulation3D.hh" 
#include "libqhullcpp/Qhull.h"
#include <fstream>
//#include "time.h"

using std::vector;

Triangulation3D::Triangulation3D(const vector<vector<G4double> >& xyz):X(xyz)
{
    RunQhull();
}

Triangulation3D::~Triangulation3D()
{}

void Triangulation3D::RunQhull()
{ 
    /* Qhull requires a column-major array of the
     * 3D points. i.e., [x1,y1,z1,x2,y2,z2,...]
     */
    //double* boxPoints = new double[3*X.size()];
    double boxPoints[3*X.size()];
    //G4cout << "Size of input = " << X.size() << " points" << G4endl;
      
    for(int i=0; i<X.size(); ++i)
    {
        boxPoints[i*3] = X[i][0];
        boxPoints[i*3+1]= X[i][1];
        boxPoints[i*3+2]= X[i][2];
    }
    
    /* Run Qhull
     * First parameter is a command to generate random points. We don't want that.
     * Second parameter is dimension of points (3)
     * Third parameter is number of points
     * Forth parameter is the 1D column-major array of points
     * Fifth parameter is qhull option flags.
     *      d = delaunay triangulation
     *      Qt = triangulate output (makes all regions simplicial)
     *      Qbb = Scales the paraboloid that Qhull creates. This helps with precision.
     *      Qz = Add a point at infinity. This somehow helps with precision...
     */
    //time_t end;
    //time_t start;
    //time(&start);
    orgQhull::Qhull hull = orgQhull::Qhull("", 3, X.size(), boxPoints, "d Qt Qbb Qz");
    //time(&end);
    //G4cout << "Time to make triangulation = " << end-start << " s" << G4endl;
        
    //delete[] boxPoints;
    
    /* Loop over all facets generated by Qhull. We want simplicial facets 
     * (non-upperdelaunay). Each facet is a tetrahedron with four vertices.
     * save the point id of each vertex of each tetrahedron.
     */
    facetT *facet;
    vertexT *vertex, **vertexp;
    int nf = hull.facetCount();
    vector<vector<int> > temp(nf,vector<int>(4,0)); //dim+1=4
    
    int i = 0;
    int j = 0;
    FORALLfacets
    {
        if (! facet->upperdelaunay)
        {
            j = 0;
            FOREACHvertex_ (facet->vertices)
            {
                temp[i][j++] = qh_pointid(vertex->point);
            }
            ++i;
        }
    }

    nf =++i;
    temp.resize(nf);

    /* Some tetrahedra will have zero volume. This is a limitation of 
     * floating-point arithmetic. Remove all zero-volume tetrahedra.
     * See Wikipedia for volume calculation: 
     * https://en.wikipedia.org/wiki/Tetrahedron#Volume
     */
    
    vector<int> goodFacet(nf,0);
    int numGood = 0;
    vector<vector<double> > Y(3,vector<double>(3,0));

    for(int ii=0; ii<nf; ++ii)
    {
        for(int jj=0; jj<3; ++jj)
        {
            Y[0][jj] = X[temp[ii][jj]][0] - X[temp[ii][jj+1]][0];
            Y[1][jj] = X[temp[ii][jj]][1] - X[temp[ii][jj+1]][1];
            Y[2][jj] = X[temp[ii][jj]][2] - X[temp[ii][jj+1]][2];
        }

        if((fabs(Det(Y))/6.0 >= DBL_MIN))
        {
            goodFacet[ii]=1;
            ++numGood;
        }
    }
        
    vector<vector<int> > good(numGood,vector<int>(4,0));
    int counter = 0;
    for(int ii=0; ii<nf; ++ii)
        if(goodFacet[ii])
           good[counter++] = temp[ii];

    tetraIndices.swap(good);
}

G4double Triangulation3D::Det(const vector<vector<G4double> >& matrix)
{
    int rows = matrix.size(); //rows = columns

    if(rows==2)
        return(matrix[0][0]*matrix[1][1] - matrix[1][0]*matrix[0][1]);
    else if(rows==3)
        return(matrix[0][0]*(matrix[1][1]*matrix[2][2]-matrix[2][1]*matrix[1][2])
                -matrix[0][1]*(matrix[1][0]*matrix[2][2]-matrix[2][0]*matrix[1][2])
                +matrix[0][2]*(matrix[1][0]*matrix[2][1]-matrix[2][0]*matrix[1][1]));
    else
    {    
        /*This function is never called for anything but 3x3 and 2x2, but just to 
         * future-proof it...
         */
        vector<vector<double> > newMatrix(rows-1,vector<double>(rows-1,0));

        double determ = 0;
        for(int i=0; i<rows; ++i) //columns
        {
            for(int j=0; j<rows-1; ++j)
                for(int k=0; k<rows-1; ++k) //columns
                    if(k<i)
                        newMatrix[j][k] = matrix[j+1][k];
                    else
                        newMatrix[j][k] = matrix[j+1][k+1];
            if((i+1)%2==0)
                determ += -1*matrix[0][i]*Det(newMatrix);
            else
                determ += matrix[0][i]*Det(newMatrix);
        }
        return(determ);
    }
}
