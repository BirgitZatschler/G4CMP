#include "G4CMPMatrix.hh"
#include <utility>

template <class T>
inline G4CMPMatrix<T>::G4CMPMatrix() : data(std::vector<T>()), ncols(0) {}

template <class T>
inline G4CMPMatrix<T>::G4CMPMatrix(size_t rows, size_t columns, const T& val) :
  data(std::vector<T>(rows*columns, val)), ncols(columns) {}

template <class T>
inline G4CMPMatrix<T>::G4CMPMatrix(const std::vector<T>& vec, size_t columns) :
  data(vec), ncols(columns) {}

template <class T>
inline G4CMPMatrix<T>::G4CMPMatrix(const std::vector<T>& vec) :
  data(vec), ncols(vec.size()) {}

template <class T>
inline typename G4CMPMatrix<T>::iterator G4CMPMatrix<T>::begin() {
  return data.begin();
}

template <class T>
inline typename G4CMPMatrix<T>::const_iterator G4CMPMatrix<T>::begin() const {
  return data.begin();
}

template <class T>
inline typename G4CMPMatrix<T>::iterator G4CMPMatrix<T>::end() {
  return data.end();
}

template <class T>
inline typename G4CMPMatrix<T>::const_iterator G4CMPMatrix<T>::end() const {
  return data.end();
}

template <class T>
inline G4CMPMatrix<T>& G4CMPMatrix<T>::operator+=(const G4CMPMatrix<T>& rhs) {
  // TODO: Add assert on data dimensions != rhs.data dimensions?
  for (size_t i = 0; i < data.size(); ++i)
    data[i] += rhs.data[i];
  return *this;
}

template <class T>
inline G4CMPMatrix<T>& G4CMPMatrix<T>::operator-=(const G4CMPMatrix<T>& rhs) {
  // TODO: Add assert on data dimensions != rhs.data dimensions?
  for (size_t i = 0; i < data.size(); ++i)
    data[i] -= rhs.data[i];
  return *this;
}

template <class T>
inline G4CMPMatrix<T>& G4CMPMatrix<T>::operator+=(const T& rhs) {
  for (size_t i = 0; i < data.size(); ++i)
    data[i] += rhs;
  return *this;
}

template <class T>
inline G4CMPMatrix<T>& G4CMPMatrix<T>::operator-=(const T& rhs) {
  for (size_t i = 0; i < data.size(); ++i)
    data[i] -= rhs;
  return *this;
}

template <class T>
inline G4CMPMatrix<T>& G4CMPMatrix<T>::operator*=(const T& rhs) {
  for (size_t i = 0; i < data.size(); ++i)
    data[i] *= rhs;
  return *this;
}

template <class T>
inline G4CMPMatrix<T>& G4CMPMatrix<T>::operator/=(const T& rhs) {
  for (size_t i = 0; i < data.size(); ++i)
    data[i] /= rhs;
  return *this;
}

// Access
template <class T>
inline T& G4CMPMatrix<T>::operator()(size_t i, size_t j) {
  return data[i*ncols + j];
}

template <class T>
inline const T& G4CMPMatrix<T>::operator()(size_t i, size_t j) const {
  return data[i*ncols + j];
}

template <class T>
inline T& G4CMPMatrix<T>::operator()(size_t i) {
  return data[i];
}

template <class T>
inline const T& G4CMPMatrix<T>::operator()(size_t i) const {
  return data[i];
}

template <class T>
inline T& G4CMPMatrix<T>::operator[](size_t i) {
  return data[i];
}

template <class T>
inline const T& G4CMPMatrix<T>::operator[](size_t i) const {
  return data[i];
}

// Modify
template <class T>
inline void G4CMPMatrix<T>::push_back(const std::vector<T>& vec) {
  // TODO: Except if vec.size() != columns?
  // Supposedly no need for data.reserve(). insert() will precalculate size.
  data.insert(data.end(), vec.begin(), vec.end());
  ++ncols;
}

template <class T>
inline void G4CMPMatrix<T>::push_back(std::vector<T>&& vec) {
  // TODO: Except if vec.size() != columns?
  // Supposedly no need for data.reserve(). insert() will precalculate size.
  data.insert(data.end(), make_move_iterator(vec.begin()),
                          make_move_iterator(vec.end()));
  ++ncols;
}

template <class T>
inline void G4CMPMatrix<T>::concat(const G4CMPMatrix<T>& rhs) {
  // TODO: Except if rhs.columns() != columns?
  // Supposedly no need for data.reserve(). insert() will precalculate size.
  data.insert(data.end(), rhs.data.begin(), rhs.data.end());
  ncols += rhs.ncols;
}

template <class T>
inline void G4CMPMatrix<T>::concat(G4CMPMatrix<T>&& rhs) {
  // TODO: Except if rhs.columns() != columns?
  // Supposedly no need for data.reserve(). insert() will precalculate size.
  data.insert(data.end(), make_move_iterator(rhs.data.begin()),
                          make_move_iterator(rhs.data.end()));
  ncols += rhs.ncols;
}

// Information
template <class T>
inline size_t G4CMPMatrix<T>::size() const {
  return data.size();
}

template <class T>
inline size_t G4CMPMatrix<T>::columns() const {
  return ncols;
}

template <class T>
inline size_t G4CMPMatrix<T>::rows() const {
  return ncols ? data.size()/ncols : 0;
}

// Comparison
template <class T>
inline bool operator==(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  return (lhs.data == rhs.data) && (lhs.ncols == rhs.ncols);
}

template <class T>
inline bool operator!=(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  return !(lhs == rhs);
}

template <class T>
inline bool operator<(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  return (lhs.data < rhs.data);
}

template <class T>
inline bool operator<=(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  return (lhs.data <= rhs.data);
}

template <class T>
inline bool operator>(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  return (lhs.data > rhs.data);
}

template <class T>
inline bool operator>=(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  return (lhs.data >= rhs.data);
}

// Negate
template <class T>
inline G4CMPMatrix<T>& operator-(G4CMPMatrix<T>& lhs) {
  return lhs *= T(-1);
}

// Matrix-Matrix math:
template <class T>
inline G4CMPMatrix<T> operator+(G4CMPMatrix<T> lhs, const G4CMPMatrix<T>& rhs) {
  return lhs += rhs;
}

template <class T>
inline G4CMPMatrix<T> operator-(G4CMPMatrix<T> lhs, const G4CMPMatrix<T>& rhs) {
  return lhs -= rhs;
}

template <class T>
inline G4CMPMatrix<T> operator*(const G4CMPMatrix<T>& lhs, const G4CMPMatrix<T>& rhs) {
  // Naive algorithm with some cache friendliness. Still pretty slow.
  G4CMPMatrix<T> out(lhs.rows(), rhs.columns());
  for (size_t i = 0; i < out.rows(); ++i)
  for (size_t k = 0; k < lhs.columns(); ++k) // lhs.columns() == rhs.rows()
  for (size_t j = 0; j < out.columns(); ++j)
    out(i,j) += lhs(i,k) * rhs(k,j);

  return out;
}

// Matrix-Number math:
template <class T>
inline G4CMPMatrix<T> operator+(G4CMPMatrix<T> lhs, const T& rhs) {
  return lhs += rhs;
}

template <class T>
inline G4CMPMatrix<T> operator+(const T& lhs, G4CMPMatrix<T> rhs) {
  return rhs += lhs;
}

template <class T>
inline G4CMPMatrix<T> operator-(G4CMPMatrix<T> lhs, const T& rhs) {
  return lhs -= rhs;
}

template <class T>
inline G4CMPMatrix<T> operator-(const T& lhs, G4CMPMatrix<T> rhs) {
  return rhs -= lhs;
}

template <class T>
inline G4CMPMatrix<T> operator*(G4CMPMatrix<T> lhs, const T& rhs) {
  return lhs *= rhs;
}

template <class T>
inline G4CMPMatrix<T> operator*(const T& lhs, G4CMPMatrix<T> rhs) {
  return rhs *= lhs;
}

template <class T>
inline G4CMPMatrix<T> operator/(G4CMPMatrix<T> lhs, const T& rhs) {
  return lhs /= rhs;
}

template <class T>
inline G4CMPMatrix<T> operator/(const T& lhs, G4CMPMatrix<T> rhs) {
  return rhs /= lhs;
}

template <class T>
std::ostream& operator<<(std::ostream& out, const G4CMPMatrix<T>& rhs) {
  out << "[";
  for (size_t i = 0; i < rhs.rows(); ++i) {
    out << "[ ";
    for (size_t j = 0; j < rhs.columns()-1; ++j)
      out << rhs(i,j) << ", ";

    out << rhs(i, rhs.columns()-1) << " ]";
    if (i < rhs.rows()-1) out << std::endl;
  }
  out << "]" << std::endl;
  return out;
}
